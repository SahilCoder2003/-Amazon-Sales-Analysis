SELECT * FROM category
SELECT * FROM orders
SELECT * FROM order_itmes
SELECT * FROM products
SELECT * FROM customers
SELECT * FROM shipping
SELECT * FROM sellers
SELECT * FROM payments
SELECT * FROM inventory

-- quetions to solve 

-- 01:TOP SELLING PRODUCTS
-- QUERY THE TOP 10 PRODUCTS BY TOTAL SALES VALUE
-- CHALLENGE: INCLUDE PRODUCT NAME,TOTAL QUANTITY SOLD AND TOTAL SALES VALUE,

SELECT * FROM order_itmes
ALTER TABLE order_itmes
ADD COLUMN total_sales float

UPDATE order_itmes
SET total_sales=quantity*price_per_unit

SELECT p.product_name,
		ot.product_id,
	sum(ot.quantity) as total_quantity,
	sum(ot.total_sales) as total_sales,
	COUNT(ot.order_id) as total_orders
	FROM products as p
JOIN order_itmes as ot
ON P.product_id=ot.product_id
GROUP BY 1,2
ORDER BY 3 DESC
LIMIT 10

-- 02:REVENUE BY CATEGORY
-- CALCULATE TOTAL REVENUE GENERATED BY EACH PRODUCT CATEGORY
-- CHALLENGE:INCLUDE THE PERCENTEGE CONTRIBUTION OF THE CATEGORY TO TOTAL REVENUE

SELECT cat.category_id,
	cat.category_name,
	sum(ot.total_sales) AS total_sales,
	ROUND(sum(ot.total_sales)::NUMERIC/(SELECT SUM(total_sales) FROM order_itmes)::NUMERIC*100 ,2)as per_contribution
	FROM category as cat
JOIN products as p
ON p.category_id=cat.category_id
JOIN order_itmes as ot
ON ot.product_id=p.product_id
GROUP BY 1,2
ORDER BY 4 DESC

03:AVERAGE ORDER VALUES(AOV)
COMPUTE THE AVERAGE ORDER VALUE FOR EACH CUSTOMER
CHALLENGE: INCLUDE ONLY CUSTOMER WITH MORE THAN 5 ORDERS

SELECT o.customer_id,
	CONCAT(c.first_name,' ',c.last_name)AS full_name,
	sum(oi.total_sales)/count(o.order_id) AS aov 
	FROM orders as o
JOIN customers as c
ON c.customer_id=o.customer_id
JOIN order_itmes as oi
ON oi.order_id=o.order_id
GROUP BY 1,2
HAVING COUNT(o.order_id)>=5
ORDER BY 3 DESC

04:MONTHLY SALES TREND
OUERY MONTHLY TOTAL SALES OVER THE PAST YEAR 
CHALLENGE:DISPLAY THE SALES TREND,,GROUPING BY MONTH,RETURN CURRENT_MONTH SALE,LAST MONTH SALE!

WITH monthly_trend AS(
SELECT 
	EXTRACT(YEAR FROM o.order_data),
	EXTRACT(MONTH FROM o.order_data),
	ROUND(sum(oi.total_sales)::NUMERIC,2)AS total_sales,
	LAG(sum(oi.total_sales)) OVER(ORDER BY EXTRACT(YEAR FROM o.order_data),EXTRACT(MONTH FROM o.order_data)) AS PRIVOUS_MONTH
FROM orders as o
JOIN order_itmes as oi
ON oi.order_id=o.order_id
WHERE o.order_data>=CURRENT_DATE - INTERVAL '2 year'
GROUP BY 1,2
ORDER BY 1,2)
SELECT *,(total_sales-privous_month)/privous_month as value_diff from monthly_trend

-- 05:customers with no purchase
-- find customers who have registerd but never placed an order
-- challenge:list customer details and the time since their registration

SELECT cus.customer_id,
		concat(cus.first_name,' ',cus.last_name) AS full_name,
		COALESCE(cast(o.* AS TEXT),'NO_ORDER') FROM customers as cus
LEFT JOIN orders as o
ON o.customer_id=cus.customer_id
WHERE o.order_id  IS NULL

06:Best-selling categories by state
identify the best-sellings product category for state
challenge:include the total sales for that category with in each state

SELECT cat.category_id,
	cat.category_name,
	cus.state,
	SUM(oi.total_sales),
	RANK() OVER(PARTITION BY cus.state ORDER BY SUM(oi.total_sales) DESC)
	FROM category as cat
JOIN products as p
ON cat.category_id=p.category_id
JOIN order_itmes as oi
ON oi.product_id=p.product_id
join orders AS o
ON o.order_id=oi.order_id
JOIN customers AS cus
ON cus.customer_id=o.customer_id
GROUP BY 1,2,3
ORDER BY 3,4 DESC


-- 07:CUSTOMERS LIFETIME VALUE(CLTVE)
-- CALCULATE THE TOTAL VALUE OF ORDERS PLACED BY EACH CUSTOMER OVER THEIR LIFETIME
-- CHALLENGE:RANK CUSTOMERS BASED ON THIER CLTV
SELECT cus.customer_id,
	CONCAT(cus.first_name,' ',cus.last_name) AS full_name,
	SUM(quantity),
	SUM(total_sales), 
	DENSE_RANK() OVER(ORDER BY SUM(total_sales)DESC)
	FROM orders as o
JOIN customers AS cus
ON cus.customer_id=o.customer_id
JOIN order_itmes as oi
ON oi.order_id=o.order_id
GROUP BY 1,2
ORDER BY 4 DESC

-- 08:INVENTORY STOCK ALERTS
-- QUERY PRODUCTS WITH STOCK LEVELS BELOW A CERTAIN THRESHOLD(E.G..LESS THAN 10 UNITS)
-- CHALLENGE:INCLUDE LAST RESTOCK DATE AND WEREHOUSE INFOMATION

SELECT p.product_name,inv.* FROM inventory as inv
JOIN products as p
ON p.product_id=inv.product_id
WHERE stock<10


-- 09:SHIPPING DELAYS
-- INDETIFY ORDERS WHERE THE SHIPPING DATE IS LATER THAN 4 DAYS AFTER THE ORDER DATE 
-- CHALLENGE: INCLUDE CUSTOMERS ORDER DETAILS AND DELIVERY PROVIDER
SELECT o.order_id,
	o.order_data,
	ship.shipping_id,
	ship.shipping_date,
	ship.shipping_provider,
	ship.delivery_status,
	ship.shipping_date-o.order_data
	FROM shipping as ship
JOIN orders as o
ON o.order_id=ship.order_id
WHERE ship.shipping_date-o.order_data >4

-- 10:PAYMENT SUCESS RATE
-- CALCULATE THE PERCENTAGE OF SUCCFULL PAYMENT ACROSS THE ORDERS
-- CHALLENGE:INCLUDE BREAKDOWNS BY PAYMENT STATUS(E..G.FAILED.PENDING)

SELECT payment_status,
	COUNT(*) AS total_count,
	ROUND(COUNT(*)::NUMERIC/(SELECT count(*) 
	FROM payments)::NUMERIC*100,2) as per
	FROM payments
GROUP BY 1

-- 11:TOP PERFORMING SELLERS
-- FIND THE TOP S SELLERS BASED ON TOTAL SALES VALUE
-- CHALLENGE:INCLUDE BOTH SUCCESSFULL AND FAILED ORDERS AND DISPLAY THEIR PERCENTAGE OF SUCCESSFUL ORDERS
WITH top_seller AS
(
SELECT sel.seller_id,sel.seller_name, SUM(total_sales) AS total_sales FROM sellers as sel
JOIN orders AS o
ON o.seller_id=sel.seller_id
JOIN order_itmes AS oi
ON oi.order_id=o.order_id
GROUP BY 1,2
ORDER BY 3 DESC
LIMIT 5
),
sep_seller AS(
SELECT o.seller_id,
	top.seller_name,
	o.order_status,
	count(*) AS total_orders 
	FROM orders AS O
JOIN top_seller as top
ON top.seller_id=o.seller_id
WHERE o.order_status in ('Cancelled' ,'Completed')
GROUP BY 1,2,3
ORDER BY 3
)

SELECT seller_id,
	seller_name,
	SUM(CASE WHEN order_status='Completed' THEN total_orders ELSE 0 END) AS COMPLETED_ORDERS,
	SUM(CASE WHEN order_status='Cancelled' THEN total_orders ELSE 0 END) AS CANCELED_ORDERS,
	SUM(total_orders),
	ROUND(SUM(CASE WHEN order_status='Completed' THEN total_orders ELSE 0 END)
		::numeric/SUM(total_orders)::numeric*100,2) AS per_completed
FROM sep_seller
GROUP BY 1,2


SELECT  sel.seller_id,sel.seller_name,o.order_status,COUNT(*),sum(oi.total_sales)FROM sellers AS sel
JOIN orders AS o
ON o.seller_id=sel.seller_id
JOIN order_itmes AS oi
ON oi.order_id=o.order_id
WHERE o.order_status in ('Cancelled' ,'Completed')
GROUP BY 1,2,3
ORDER BY 2
limit 5



-- 12:FIND THE CUSTOMER WHOSE TOTAL PURCHASE VALUE EXCEEDS THE AVERAGE ORDER VALUE
SELECT * FROM
(
SELECT cus.customer_id,CONCAT(cus.first_name,' ',cus.last_name),SUM(total_sales) AS total_sales FROM customers as cus
JOIN orders AS o
ON o.customer_id=cus.customer_id
JOIN order_itmes AS oi
ON oi.order_id=o.order_id
GROUP BY 1,2)
WHERE total_sales>=(SELECT sum(total_sales)/count(*) FROM order_itmes)
ORDER BY 3 DESC

-- 13:PRODUCT PROFIT MARGIN
-- CALCULATE THE PROFIT MARGIN FOR EACH PRODUCT(DIFFERENCE BETWEEN PRICE AND CONST OF GOODS SOLD)
-- CHALLENGE: RANK PRODUCT BY THEIR PROFIT MARGING SHOWING HIGHEST TO LOWEST

SELECT p.product_id,
	p.product_name,
	SUM(oi.total_sales-(p.cogs*oi.quantity))/SUM(total_sales)*100 AS total_profit,
	RANK() OVER(ORDER BY SUM(oi.total_sales-(p.cogs*oi.quantity))/SUM(total_sales)*100 DESC )
FROM products AS P
JOIN order_itmes AS oi
ON p.product_id=oi.product_id
GROUP BY 1,2

-- 14:MOST RETURNED PRODUCT
-- QUERY THE TOP 10 PRODUCTS BY THE NUMBER OF RETURNS 
-- CHALLENGES:DISPLAY THE RETURN RATE AS A PERCENTAGE OF TOTAL UNITS SOLD FOR EACH PRODUCT

SELECT p.product_id,
	p.product_name,
	count(*) as order_id,
	SUM(CASE WHEN o.order_status='Returned' THEN 1 ELSE 0 END) AS retuned_count,
	SUM(CASE WHEN o.order_status='Returned' THEN 1 ELSE 0 END)::numeric/count(*)::numeric*100 AS PER FROM products as p
JOIN order_itmes as oi
ON p.product_id=oi.product_id
JOIN orders as o
ON o.order_id=oi.order_id
GROUP BY 1,2
ORDER BY 5 DESC
LIMIT 10

-- 15:INACTIVE SELLERS
-- IDENTIFY SELLERS WHO HAVEN'T MADE ANY SALES IN THE LAST 6 MONTHS
-- CHALLENGE: SHOW THE LAST SALE DATE AND TOTAL SALES FORM THOSE SELLERS

WITH inactive_seller as(
SELECT * FROM sellers
WHERE seller_id NOT IN (SELECT seller_id FROM orders ID WHERE order_data>=CURRENT_DATE - INTERVAL '3 year'))
SELECT ins.seller_id,
	ins.seller_name,
	max(o.order_data) as last_date 
	FROM inactive_seller as ins
JOIN orders as o
ON o.seller_id=ins.seller_id
GROUP BY 1,2

-- 16:IDENTIFY CUSTOMERS INTO RETURNING OR NEW
-- IF THE CUSTOMER HAS DONE MORE THAN 5 RETURN CATEGORIZE THEM AS REUTRNING OTHERWISE NEW 
-- CHALLENGE:LIST CUSTOMERS ID,NAME,TOTAL ORDERS,TOTAL RETURNS
SELECT * ,CASE WHEN return_count>=5 THEN 'RETURNING' ELSE 'NEW' END AS CUSTOMER_STATUS FROM(
SELECT cus.customer_id,
	CONCAT(cus.first_name,' ',cus.last_name) AS full_name,
	count(o.order_id) AS total_prders,
	SUM(CASE WHEN o.order_status='Returned' THEN 1 ELSE 0 END) AS return_count
	FROM customers AS cus
JOIN orders AS o
ON o.customer_id=cus.customer_id
GROUP BY 1,2
ORDER BY 4 DESC)

-- 17:TOP 5 CUSTOMER BY ORDERS IN EACH STATE 
-- INDENTIFY THE TOP  5 CUSTOMER WITH THE HIGHEST NUMBER OF ORDERS FOR EACH STATE
-- CHALLENGE:INCLUDE THE NUMBER OF ORDERS AND TOTAL SALES FOR EACH CUSTOMER
SELECT * FROM(
SELECT cus.customer_id,
	CONCAT(cus.first_name,cus.last_name) AS full_name ,
	cus.state,
	count(o.order_id) AS total_orders,
	SUM(oi.total_sales) AS total_sales,
	DENSE_RANK() OVER(PARTITION BY cus.state ORDER BY count(o.order_id) DESC) AS RANK
	FROM customers AS cus
JOIN orders AS o
ON o.customer_id=cus.customer_id
JOIN order_itmes AS oi
ON oi.order_id=o.order_id
GROUP BY 1,2,3)
WHERE RANK<=5

-- 18:REVENUE BY SHIPPING PROVIDER 
-- CALCULATE THE TOTAL REVENUE HANDLED BY EACH SHIPPING PROVIDER
-- CHALLENGE:INCLUDE THE TOTAL NUMBER OF ORDERS HANDLED AND THE AVERAGE DELIVERY TIME FOR EACH PROVIDER

SELECT ship.shipping_provider,
		COUNT(o.order_id) AS total_orders,
		AVG(ship.shipping_date-o.order_data)::NUMERIC AS avg_deilvery_time,
		SUM(oi.total_sales ) AS total_sales 
		FROM shipping AS ship
JOIN orders AS o
ON o.order_id=ship.order_id 
JOIN order_itmes AS oi
ON oi.order_id=o.order_id
GROUP BY 1

19:TOP 10 PRODUCT WITH HIGHEST DECREASIGN REVENUE RATIO COMPARE TO LAST YEAR(2022) AND CURRENT YEAR (2023)
CHALLENG:RETURN PRODUCT_ID,PRODUCT_NAME,CATEGORY_NAME,2022 REVENUE AND 2023 REVENUE DECREASE RATION AT END ROUND
NOTE:DECREASE_RATION=CR-LS/LS*100 

SELECT *,COALESCE((current_year-last_year)/last_year*100 ,0)as diff FROM(
SELECT p.product_id,
	p.product_name,
	cat.category_name,
	SUM(CASE WHEN EXTRACT(YEAR FROM o.order_data)='2022' THEN oi.total_sales END) AS last_year,
	SUM(CASE WHEN EXTRACT(YEAR FROM o.order_data)='2023' THEN oi.total_sales END) AS current_year,
	SUM(CASE WHEN EXTRACT(YEAR FROM o.order_data)='2022' THEN oi.total_sales END)-
							SUM(CASE WHEN EXTRACT(YEAR FROM o.order_data)='2023' THEN oi.total_sales END)
	 FROM products AS p
JOIN category AS cat
ON cat.category_id=p.category_id
JOIN order_itmes AS oi
ON oi.product_id=p.product_id
JOIN orders AS o
ON o.order_id=oi.order_id
GROUP BY 1,2,3


-- FINAL TASL
-- CREATE A FUNCTION AS SOON AS THE PRODUCT IS SOLD THE SAME QUANTITY SHOULD REDUCED 
-- FROM INVENTORY TABLE AFTER ADDING ANY SALES RECORDS IT SHOULD UPDATE
--  THE STOCK IN THE INVENTORY TABLE BASED ON THE PRODUCT AND QTY PURCHASEE
SELECT * FROM order_itmes
order_id,
order_data,
cusomer_id,
seller_id,
order_item_id,
product_id,
quantity,


CREATE OR REPLACE PROCEDURE 
			update_function3
				(p_order_id INT,
				p_customer_id INT,
				p_seller_id INT,
				p_order_item_id INT,
				p_product_id INT,
				p_quantity INT)
LANGUAGE PLPGSQL
AS
$$
DECLARE
	v_price FLOAT;
	v_count INT;
BEGIN 

	SELECT 
		 price
	 INTO 
		 v_price
		 FROM PRODUCTS
 		WHERE product_id=p_product_id ;
 
	SELECT 
	COUNT(*)
	INTO
	v_count
	FROM 
	inventory
	WHERE product_id=p_product_id
	AND 
	stock>=p_quantity;
	
	IF v_count >0 THEN
		  INSERT INTO orders(order_id,order_data,customer_id,seller_id)
			VALUES(p_order_id,CURRENT_DATE,p_customer_id,p_seller_id);

  		INSERT INTO order_itmes(order_item_id,order_id,product_id,quantity,price_per_unit,total_sales)
  		VALUES(p_order_item_id,p_order_id,p_product_id,p_quantity,v_price,p_quantity*v_price);

	  UPDATE inventory
	  SET stock=stock - p_quantity
	  WHERE product_id=p_product_id;

	  RAISE NOTICE 'THANK YOU FOR PURCHASING';


	ELSE 
		RAISE NOTICE 'PRODUCT IS NOT AVAILABEE';

	END IF;
END
$$
CALL update_function3(25000,2,5,25001,1,40);



